
#include <list>
#include <iostream>
#include <fstream>
#include <string>

#include "Log.h"
#include "MicroProcessor.h"

using Registers_t = tones::MicroProcessor::Registers_t;

struct LogLine {
    Registers_t regs;
    std::string text;
};

/**
 * @brief Parse the ground truth from a log file
 */
class LogParser
{
public:

    int size() const
    {
        return _lines.size();
    }

    void next()
    {
        if (_it != _lines.end()) {
            ++_it;
        }
    }

    const Registers_t &regs() const {
        static Registers_t regs;
        return _lines.end() == _it ? regs : _it->regs;
    }

    const std::string &line() const {
        static std::string str = "";
        return _lines.end() == _it ? str : _it->text;
    }

    void load(const std::string &filepath)
    {
        if (!filepath.size())
            return;

        std::ifstream file(filepath, std::ios_base::in);
        if (!file)
            return;

        std::string line;
        Registers_t regs;

        _lines.clear();
        while (std::getline(file, line)) {
            if (parseReg(line, regs)) {
                _lines.emplace_back(LogLine({regs, line}));
            } else {
                LOG_WARN() << "Skip log line: " << line;
            }
        }

        _it = _lines.begin();
    }

    virtual bool parseReg(const std::string &str, Registers_t &reg) = 0;

protected:

    std::list<LogLine> _lines;
    std::list<LogLine>::iterator _it;
};

/**
 * @brief For log files generated by FCEUX
 *
 * Homepage: https://fceux.com/web/home.html
 */
class FceuxLogParser : public LogParser
{
    bool parseReg(const std::string &str, Registers_t &reg) override
    {
        char p[8] = { 0 };
        char s[128] = { 0 };

        int32_t ret = sscanf(str.c_str(), "A:%hhx X:%hhx Y:%hhx S:%hhx P:%8c   $%hx: %s",
                             &(reg.A), &(reg.X), &(reg.Y), &(reg.S), p, &(reg.PC), s);

        uint16_t reg_P = 0;
        for (int i = 0; i < 8; ++i) {
            int bit = p[i] >= 'A' && p[i] <= 'Z' ? 1 : 0;
            reg_P |= bit;
            reg_P <<= 1;
        }
        reg.P = (reg_P >> 1 | 0x20) & 0xff; // the unused bit is set to 0 in FCEUX

        return ret == 7;
    }
};

/**
 * @brief For log files generated by Nintendulator
 *
 * Homepage: https://www.qmtpro.com/~nes/nintendulator/
 */
class NintendulatorLogParser : public LogParser
{
    bool parseReg(const std::string &str, Registers_t &reg) override
    {
        char s1[64] = { 0 }; // source code
        char s2[64] = { 0 }; // TODO: PPU, CYC

        int ret = sscanf(str.c_str(), "%hx  %40c  A:%hhx X:%hhx Y:%hhx P:%hhx SP:%hhx %s",
                           &(reg.PC), s1, &(reg.A), &(reg.X), &(reg.Y), &(reg.P), &(reg.S), s2);

        return 8 == ret;
    }
};
